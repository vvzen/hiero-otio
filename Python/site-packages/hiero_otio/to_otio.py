import os
import re

from constants import MARKER_COLOR_MAP

# ------------------------------------------------------------------------------
# HIERO --> OTIO
# ------------------------------------------------------------------------------

def add_metadata(metadata, hiero_item):
    for key, value in metadata.get('Hiero', dict()).items():
        if key == 'source_type':
            # Only used internally to reassign tag to correct Hiero item
            continue

        if isinstance(value, dict):
            add_metadata(value, hiero_item)
            continue

        if value is not None:
            if not key.startswith('tag.'):
                key = 'tag.' + key

            hiero_item.metadata().setValue(key, str(value))

def get_marker_color(tag):
        icon = tag.icon()
        pat = r'icons:Tag(?P<color>\w+)\.\w+'

        res = re.search(pat, icon)
        if res:
            color = res.groupdict().get('color')
            if color.lower() in MARKER_COLOR_MAP:
                return MARKER_COLOR_MAP[color.lower()]

        return otio.schema.MarkerColor.RED

def add_hiero_markers_to_otio(hiero_item, otio_item):

    for tag in track_item.tags():
        if not tag.visible():
            continue

        # Hiero adds this tag to a lot of clips
        if tag.name() == 'Copy':
            continue

        frame_rate = get_trackitem_framerate(track_item)

        marked_range = otio.opentime.TimeRange(
            start_time=otio.opentime.RationalTime(
                tag.inTime(),
                frame_rate
            ),
            duration=otio.opentime.RationalTime(
                int(tag.metadata().dict().get('tag.length', '0')),
                frame_rate
            )
        )

        metadata = dict(
            Hiero=tag.metadata().dict()
        )
        # Store the source item for future import assignment
        metadata['Hiero']['source_type'] = track_item.__class__.__name__

        marker = otio.schema.Marker(
            name=tag.name(),
            color=get_marker_color(tag),
            marked_range=marked_range,
            metadata=metadata
        )

        otio_item.markers.append(marker)

def get_trackitem_framerate(track_item):
    """Get the framerate of a TrackItem, or fallback on the parent

    :param track_item: TrackItem instance
    :type track_item: core.Hiero.Python.TrackItem

    :return: numerator and denominator components of the framerate
    :rtype: tuple of int
    """

    framerate = track_item.source().framerate()
    framerate_num, framerate_den = framerate.toRational()

    # Apparently, audio tracks have a 0/0 framerate according to Hiero
    # So we need to fallback on the sequence framerate
    if framerate_den == 0:
        framerate = track_item.parent().parent().framerate()
        framerate_num, framerate_den = framerate.toRational()

    return framerate_num, framerate_den


def get_trackitem_ranges(track_item):
    """Get what OTIO calls the source and available ranges of a specific
    Hiero TrackItem.
    I suggested to have a look at their docs to understand what these concepts
    refer to, but basically it's the real vs ideal ranges of a clip:
    https://opentimelineio.readthedocs.io/en/latest/tutorials/time-ranges.html

    :param track_item: TrackItem instance
    :type track_item: core.Hiero.Python.TrackItem

    :return: source and available ranges of the Clip on the TrackItem
    :rtype: tuple of opentimelineio.schema.TimeRange
    """

    hiero_clip = track_item.source()

    source_framerate_num, source_framerate_den = get_trackitem_framerate(
        track_item)

    # Handle reversed video/audio
    if track_item.playbackSpeed() < 0:
        start = track_item.sourceOut()

    else:
        start = track_item.sourceIn()

    # Get the total length of the clip
    source_start_time = otio.opentime.RationalTime(
        start, source_framerate_num / source_framerate_den)

    # The fact that they represent a duration as a RationalTime
    # breaks my brain a bit, but if you think of it
    # the duration of something is just a point in time
    # after a given start time
    source_duration = otio.opentime.RationalTime(
        track_item.duration(), source_framerate_num / source_framerate_den)

    source_range = otio.opentime.TimeRange(start_time=source_start_time,
                                           duration=source_duration)

    # Get the available range from the media source, if present
    available_range = None
    if hiero_clip.mediaSource().isMediaPresent():

        start_time = otio.opentime.RationalTime(
            0,
            source_framerate_num / source_framerate_den)

        duration = otio.opentime.RationalTime(
            hiero_clip.mediaSource().duration(),
            source_framerate_num / source_framerate_den)

        available_range = otio.opentime.TimeRange(start_time=start_time,
                                                  duration=duration)

    return source_range, available_range


def otio_clips_from_track_item(track_item_index, track_item):
    """Returns a list of OTIO Clips and Gaps from the given information
    about the Hiero track. Gaps are added only if there's a space before the
    clip, not after it.

    :param track_item_index: index of the track item in the track container
    :type track_item_index: int

    :param track_item: hiero track item
    :type track_item: core.Hiero.Python.TrackItem

    :return: a list of clips + eventual gaps present in the hiero track item
    :rtype: list of opentimelineio.schema.Clip or opentimelineio.schema.Clip
    """

    hiero_clip = track_item.source()
    returned_clips = []

    previous_track_item = None
    if track_item_index > 0:
        previous_track_item = track_item.parent().items()[track_item_index - 1]

    framerate = hiero_clip.framerate()
    source_framerate_num, source_framerate_den = framerate.toRational()

    # Fallback on the parent
    if source_framerate_den == 0:
        source_framerate_num, source_framerate_den = get_trackitem_framerate(
            track_item)

    gap = None
    gap_range = None

    # Understand if there's a gap between the previous clip and this one
    if previous_track_item:
        gap = track_item.timelineIn() - previous_track_item.timelineOut() - 1

    # ..or between the start of the sequence and this first clip
    elif track_item.timelineIn() > 0:
        gap = track_item.timelineIn()

    # If the frames are not consecutive, create a Gap
    if gap:
        gap_range = otio.opentime.TimeRange(duration=otio.opentime.RationalTime(
            gap, source_framerate_num / source_framerate_den))
        returned_clips.append(
            otio.schema.Gap(name="gap_before::%s" % track_item.name(),
                            source_range=gap_range))

    clip_source_range, clip_available_range = get_trackitem_ranges(track_item)

    # Create the actual Clip
    otio_clip = otio.schema.Clip(name=track_item.name(),
                                 source_range=clip_source_range)


    # Add the Media Reference
    media_reference = otio.schema.MissingReference()
    if hiero_clip.mediaSource().isMediaPresent():

        media_path = None
        media_source = hiero_clip.mediaSource()

        if media_source.singleFile():
            path = media_source.fileinfos()[0].filename()
            media_reference = otio.schema.ExternalReference(
                target_url=u'{}'.format(path),
                available_range=clip_available_range
            )
            media_path = media_source.fileinfos()[0].filename

        else:
            if OTIO_MINOR_VERSION < 13:
                # After this PR:
                # https://github.com/PixarAnimationStudios/OpenTimelineIO/pull/722
                # they added a more specific ImageSequenceReference class
                first_file = media_source.fileinfos()[0]
                media_path, basename = os.path.split(first_file.filename())
                _, name_suffix = os.path.splitext(first_file.filename())
                media_reference = otio.schema.ExternalReference(
                    target_url=media_path, available_range=clip_available_range)
            else:
                first_file = media_source.fileinfos()[0]
                _, name_suffix = os.path.splitext(first_file.filename())
                media_path, basename = os.path.split(first_file.filename())
                name_prefix = media_source.filenameHead()
                start_frame = first_file.startFrame()
                frame_zero_padding = media_source.filenamePadding()

                media_reference = otio.schema.ImageSequenceReference(
                    target_url_base=media_path + os.sep,
                    name_prefix=name_prefix,
                    name_suffix=name_suffix,
                    start_frame=start_frame,
                    frame_zero_padding=frame_zero_padding,
                    rate=source_framerate_num / source_framerate_den,
                    available_range=clip_available_range)

    otio_clip.media_reference = media_reference

    # Add eventual linear time remappings
    playback_speed = track_item.playbackSpeed()
    retime_effect = None

    if playback_speed == 0.0:
        retime_effect = otio.schema.FreezeFrame()
    elif playback_speed != 1.0:
        retime_effect = otio.schema.LinearTimeWarp(time_scalar=playback_speed)

    if retime_effect:
        otio_clip.effects.append(retime_effect)

    returned_clips.append(otio_clip)

    return returned_clips


def sequence_to_otio(sequence, add_markers=False,
                     track_cb=None, track_item_cb=None):
    """Generates a OTIO Timeline based on the input Hiero sequence.
    Since all of this needs is currently blocking, a callback function can be
    passed in to get progress about the current stage of the processing.

    :param sequence: Hiero sequence instance
    :type sequence: core.Hiero.Python.Sequence

    :param add_markers: whether to add markers to the OTIO clips or not
    :type add_markers: bool

    :param track_cb: callback function called at each track. The cb args are: the OTIO track and the hiero sequence. Defaults to None
    :type track_cb: callable, optional

    :param track_item_cb: callback function called at each track item. The cb args are: the OTIO clip and the hiero track item. Defaults to None
    :type track_item_cb: callable, optional

    :return: the resulting OTIO timeline
    :rtype: opentimelineio.schema.Timeline
    """

    timeline = otio.schema.Timeline()
    timeline.name = sequence.name()

    seq_framerate_num, seq_framerate_den = sequence.framerate().toRational()

    timeline.global_start_time = otio.opentime.RationalTime(
        sequence.timecodeStart(), seq_framerate_num / seq_framerate_den)

    # Go through all the audio/video tracks in the given Sequence
    for track_index, track in enumerate(sequence.items()):
        track_name = track.name()

        track_kind = None
        if isinstance(track, hiero.core.VideoTrack):
            track_kind = otio.schema.TrackKind.Video
        elif isinstance(track, hiero.core.AudioTrack):
            track_kind = otio.schema.TrackKind.Audio
        else:
            log.error("Found non Video/Audio track: %s, skipping!", track_name)
            continue

        otio_track = otio.schema.Track(name=track_name, kind=track_kind)

        if track_cb:
            track_cb(otio_track, track)

        # Add the clips of this track
        for tii, track_item in enumerate(track.items()):

            if isinstance(track_item.source(), hiero.core.Clip):

                # Clips include eventual gaps
                clips = otio_clips_from_track_item(tii, track_item)
                if not clips:
                    # Each track item must contain at least 1 clip!
                    # what happened here?
                    log.error(
                        "Hiero track item %s couldn't be "
                        "converted to a OTIO Clip!", track_item)
                    continue

                try:
                    otio_clip = [
                        c for c in clips if isinstance(c, otio.schema.Clip)
                    ][0]

                    if add_markers:
                        add_markers(track_item, otio_clip)
                        add_markers(track_item.source(), otio_clip)

                except IndexError:
                    log.error("No OTIO clip could be created from %s",
                              track_item)
                    otio_clip = None

                for i, clip in enumerate(clips):
                    otio_track.append(clip)

                if track_item_cb:
                    track_item_cb(otio_clip, track_item)

        timeline.tracks.append(otio_track)

        if add_markers:
            add_markers(sequence, timeline.tracks)

    return timeline
