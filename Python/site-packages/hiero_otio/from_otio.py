from .constants import TRANSITION_TYPES

# ------------------------------------------------------------------------------
# OTIO --> HIERO
# ------------------------------------------------------------------------------
# Currently supported features when importing a OTIO File:
# - Simple Flat Timeline    [X]
# - Multiple tracks         [X]
# - Linear Retimes :        [X]
# - Freeze Frames :         [X]
# - Transitions:            [?] Untested
# - Non Linear Retimes :    [?] Unsupported

def add_markers(otio_item, hiero_item, tagsbin):
    if isinstance(otio_item, (otio.schema.Stack, otio.schema.Clip)):
        markers = otio_item.markers

    elif isinstance(otio_item, otio.schema.Timeline):
        markers = otio_item.tracks.markers

    else:
        markers = []

    for marker in markers:
        meta = marker.metadata.get('Hiero', dict())
        if 'source_type' in meta:
            if hiero_item.__class__.__name__ != meta.get('source_type'):
                continue

        marker_color = marker.color

        _tag = get_tag(marker.name, tagsbin)
        if _tag is None:
            _tag = get_tag(marker_color_map[marker_color], tagsbin)

        if _tag is None:
            _tag = hiero.core.Tag(marker_color_map[marker.color])

        start = marker.marked_range.start_time.value
        end = (
            marker.marked_range.start_time.value +
            marker.marked_range.duration.value
        )

        if hasattr(hiero_item, 'addTagToRange'):
            tag = hiero_item.addTagToRange(_tag, start, end)

        else:
            tag = hiero_item.addTag(_tag)

        tag.setName(marker.name or marker_color_map[marker_color])
        # tag.setNote(meta.get('tag.note', ''))

        # Add metadata
        add_metadata(marker.metadata, tag)

def get_transition_type(otio_item, otio_track):
    """Dummy function that returns the transition type based on the input
    otio item and its neighbors

    :param otio_item: instance clip or gap
    :type otio_item: otio.schema.Gap or otio.schema.Clip

    :param otio_track: instance of OTIO track
    :type otio_track: otio.schema.VideoTrack or otio.schema.AudioTrack

    :return: type of transition
    :rtype: str
    """

    _in, _out = otio_track.neighbors_of(otio_item)

    if isinstance(_in, otio.schema.Gap):
        _in = None

    if isinstance(_out, otio.schema.Gap):
        _out = None

    if _in and _out:
        return TRANSITION_TYPES.dissolve

    elif _in and not _out:
        return TRANSITION_TYPES.fade_out

    elif not _in and _out:
        return TRANSITION_TYPES.fade_in

    else:
        return TRANSITION_TYPES.unknown

def create_track(otio_track, track_num):
    """Creates a Hiero track based on a OTIO track

    :param otio_track: input OTIO track
    :type otio_track: otio.schema.VideoTrack or otio.schema.AudioTrack

    :param track_num: number of the track
    :type track_num: int

    :raises RuntimeError: in case the OTIO track isn't a known kind

    :return: Hiero track instance
    :rtype: core.Hiero.Python.TrackItem
    """

    if hasattr(otio_track, "kind"):
        kind = otio_track.kind
    else:
        raise RuntimeError("Unknown OTIO track kind! %s" % otio_track)

    if kind == otio.schema.TrackKind.Video:
        track = hiero.core.VideoTrack(
            otio_track.name or "Video{n}".format(n=track_num)
        )

    else:
        track = hiero.core.AudioTrack(
            otio_track.name or "Audio{n}".format(n=track_num)
        )

    return track


def create_trackitem(playhead, track, otio_clip, hiero_clip):
    """Creates Hiero Track item given the input OTIO Clip

    :param playhead: current timeline playhead
    :type playhead: int

    :param track: instance of otio track
    :type track: otio.schema.VideoTrack or otio.schema.AudioTrack

    :param otio_clip: instance of otio clip
    :type otio_clip: otio.schema.Clip

    :param hiero_clip: instance of hiero clip
    :type hiero_clip: core.Hiero.Python.Clip

    :return: instance of TrackItem
    :rtype: core.Hiero.Python.TrackItem
    """

    source_range = otio_clip.source_range

    track_item = track.createTrackItem(otio_clip.name)
    track_item.setPlaybackSpeed(source_range.start_time.rate)
    track_item.setSource(hiero_clip)

    # Assume non re-times by default
    time_multiplier = 1.0

    # Search for simple re-time effects to apply
    for effect in otio_clip.effects:

        if isinstance(effect, otio.schema.LinearTimeWarp):
            time_multiplier = effect.time_scalar

        elif isinstance(effect, otio.schema.FreezeFrame):
            time_multiplier = 0.0

    # If playback speed is reversed, swap source in and out
    if track_item.playbackSpeed() < 0:
        source_out = source_range.start_time.value
        source_in = source_range.end_time_inclusive().value

        timeline_in = playhead + source_out
        timeline_out = (
            timeline_in +
            source_range.duration.value
        ) - 1
    # Normal playback speed
    else:
        source_in = source_range.start_time.value
        source_out = source_range.end_time_inclusive().value

        timeline_in = playhead
        timeline_out = (
            timeline_in +
            source_range.duration.value
        ) - 1

    # Set source and timeline in/out points
    track_item.setTimes(
        timeline_in, timeline_out,
        source_in, source_out
    )

    # Apply eventual freeze frames since they need to happen after
    # the source has been set
    if time_multiplier != 1.0:
        track_item.setPlaybackSpeed(
            track_item.playbackSpeed() * time_multiplier
        )

    # Link audio to video when possible
    if isinstance(track, hiero.core.AudioTrack):
        for other in track.parent().trackItemsAt(playhead):
            if other.source() == hiero_clip:
                track_item.link(other)

    return track_item

def find_trackitem(otio_clip, hiero_track):
    for item in hiero_track.items():
        if item.timelineIn() == otio_clip.range_in_parent().start_time.value:
            if item.name() == otio_clip.name:
                return item

    return None

def get_neighbor_trackitems(otio_item, otio_track, hiero_track):
    """Finds the track items to the left and right to the given one

    :param otio_item: otio clip/gap instance
    :type otio_item: otio.schema.Clip or otio.schema.Gap

    :param otio_track: otio track instance
    :type otio_track: otio.schema.Track

    :param hiero_track: hiero track instance
    :type hiero_track: core.Hiero.Python.TrackItem

    :return: left and right track items
    :rtype: tuple
    """

    _in, _out = otio_track.neighbors_of(otio_item)
    trackitem_in = None
    trackitem_out = None

    if _in:
        trackitem_in = find_trackitem(_in, hiero_track)

    if _out:
        trackitem_out = find_trackitem(_out, hiero_track)

    return trackitem_in, trackitem_out


def apply_transition(otio_track, otio_item, track):

    warning = None

    # Figure out type of transition
    transition_type = get_transition_type(otio_item, otio_track)

    # Needed to create the transitions in the Hiero api
    # Video transitions are functions named createDissolveTransition...
    # Audio transitions are functions named createAudioDissolveTransition...
    kind = ""
    if isinstance(track, hiero.core.AudioTrack):
        kind = "Audio"

    # Gather TrackItems involved in transition
    item_in, item_out = get_neighbor_trackitems(
        otio_item,
        otio_track,
        track
    )

    # Sanity check on the previous/following track items
    if not item_in:
        warning = (
            "Couldn't find previous TrackItem "
            "for transition in clip {name} !"
        ).format(name=otio_item.name)
        return warning

    if not item_out:
        warning = (
            "Couldn't find previous TrackItem "
            "for transition in clip {name}!"
        ).format(name=otio_item.name)
        return warning

    # Create transition object depending on the transition type
    if transition_type == TRANSITION_TYPES.dissolve:
        transition_func = getattr(
            hiero.core.Transition,
            "create{kind}DissolveTransition".format(kind=kind)
        )

        try:

            transition = transition_func(
                item_in,
                item_out,
                otio_item.in_offset.value,
                otio_item.out_offset.value
            )

        # Catch error raised if transition is bigger than TrackItem source
        except RuntimeError as e:
            transition = None
            warning = (
                "Unable to apply transition '{name}': {e} "
                "Ignoring the transition."
            ).format(name=otio_item.name, e=e)

    elif transition_type == TRANSITION_TYPES.fade_in:
        transition_func = getattr(
            hiero.core.Transition,
            "create{kind}FadeInTransition".format(kind=kind)
        )

        # Warn user if part of fade is outside of clip
        if otio_item.in_offset.value:
            warning = (
                "Fist half of transition '{t}' is outside of clip and "
                "not valid in Hiero. Only applied second half.").format(t=otio_item.name)

        transition = transition_func(
            item_out,
            otio_item.out_offset.value
        )

    elif transition_type == TRANSITION_TYPES.fade_out:
        transition_func = getattr(
            hiero.core.Transition,
            "create{kind}FadeOutTransition".format(kind=kind)
        )
        transition = transition_func(
            item_in,
            otio_item.in_offset.value
        )

        # Warn user if part of fade is outside of clip
        if otio_item.out_offset.value:
            warning = (
                "Second half of transition '{name}' is outside of clip "
                "and not valid in Hiero. Only applied first half."
            ).format(name=otio_item.name)

    else:
        log.warning("Unknown transition (%s) in item %s !", transition_type, otio_item)

    # Finally, apply the transition
    if transition:
        track.addTransition(transition)

    return warning

def create_offline_mediasource(otio_clip, path=None):
    """Create an offline MediaSource in Hiero to signals that the media for that
    Hiero clip isn't found or isn't available

    :param otio_clip: instance of OTIO clip
    :type otio_clip: otio.schema.Clip

    :param path: path to the media, defaults to None
    :type path: str, optional

    :return: the media source instance
    :rtype: core.Hiero.Python.MediaSource
    """
    hiero_rate = hiero.core.TimeBase(
        otio_clip.source_range.start_time.rate
    )

    legal_media_refs = (
        otio.schema.ExternalReference,
        otio.schema.ImageSequenceReference
    )
    if isinstance(otio_clip.media_reference, legal_media_refs):
        source_range = otio_clip.available_range()

    else:
        source_range = otio_clip.source_range

    if path is None:
        path = otio_clip.name

    media = hiero.core.MediaSource.createOfflineVideoMediaSource(
        path,
        source_range.start_time.value,
        source_range.duration.value,
        hiero_rate,
        source_range.start_time.value
    )

    return media

def create_clip(otio_clip, tags_bin, sequence_bin):

    media = None
    otio_media = otio_clip.media_reference

    if isinstance(otio_media, otio.schema.ExternalReference):
        media = hiero.core.MediaSource(otio_media.target_url)

    elif isinstance(otio_media, otio.schema.ImageSequenceReference):
        media = hiero.core.MediaSource(otio_media.abstract_target_url("#"))

    elif isinstance(otio_media, otio.schema.GeneratorReference):
        raise NotImplementedError("Importing a GeneratorReference isn't "
                                  "yet implemented!")

    else:
        media = create_offline_mediasource(otio_clip, None)

    if not media or media.isOffline():
        if isinstance(otio_media, otio.schema.MissingReference):
            log.warning("clip %s has MissingReference, "
                        "creating offline MediaSource", otio_clip.name)
            media = create_offline_mediasource(otio_clip, None)
        else:
            log.warning("Creating offline MediaSource for clip %s",
                        otio_clip.name)

    # Reuse a previous clip if possible
    clip = None
    for item in sequence_bin.clips():
        if item.activeItem().mediaSource() == media:
            clip = item.activeItem()
            break

    # ..otherwise, create a new one
    if not clip:
        clip = hiero.core.Clip(media)
        sequence_bin.addItem(hiero.core.BinItem(clip))

    return clip

def sequence_from_otio(otio_timeline, project=None,
                       sequence=None, warnings_cb=None):
    """Generate a Hiero Sequence from a OTIO timeline

    :param otio_timeline: input OTIO timeline instance
    :type otio_timeline: otio.schema.Timeline

    :param project: hiero project instance, defaults to None
    :type project: core.Hiero.Python.Project, optional

    :param sequence: hiero sequence instance, defaults to None
    :type sequence: core.Hiero.Python.Sequence, optional

    :param warnings_cb: will be called at the end with a \n separated string of warnings encountered
    :type warnings_cb: callable
    """

    if project is None:
        if sequence:
            project = sequence.project()

        else:
            # Per version 12.1v2 there is no way of getting active project
            project = hiero.core.projects(hiero.core.Project.kUserProjects)[-1]

    project_bin = project.clipsBin()

    # Create a Sequence if needed
    if not sequence:
        sequence = hiero.core.Sequence(otio_timeline.name or 'OTIOSequence')

        # Set sequence settings from otio timeline if available
        if hasattr(otio_timeline, 'global_start_time'):
            if otio_timeline.global_start_time:
                start_time = otio_timeline.global_start_time
                sequence.setFramerate(start_time.rate)
                sequence.setTimecodeStart(start_time.value)

        # Create a Bin to hold clips
        project_bin.addItem(hiero.core.BinItem(sequence))

        sequence_bin = hiero.core.Bin(sequence.name())
        project_bin.addItem(sequence_bin)

    else:
        sequence_bin = project_bin

    # Get tagsBin
    tags_bin = hiero.core.project("Tag Presets").tagsBin()

        # TODO: when/if it will be needed, add timeline markers

    if isinstance(otio_timeline, otio.schema.Timeline):
        tracks = otio_timeline.tracks

    else:
        tracks = [otio_timeline]

    for tracknum, otio_track in enumerate(tracks):
        playhead = 0
        _transitions = []

        # Generate all the tracks
        track = create_track(otio_track, tracknum)
        sequence.addTrack(track)

        # For each track, generate the relevant Hiero clips
        for itemnum, otio_clip in enumerate(otio_track):

            # Before supporting complex (and currently unneeded) stuff
            # let's keep things clean and easy to follow
            if isinstance(otio_clip, (otio.schema.Track, otio.schema.Stack)):
                log.error("Error with Track: %s", otio_clip)
                log.error("Currently there's no support for importing nested sequences/tracks!")
                continue

            # There's no way to represenet a gap/filler in Hiero for now
            elif isinstance(otio_clip, otio.schema.Gap):
                playhead += otio_clip.source_range.duration.value

            # Store transitions for when all clips in the track are created
            elif isinstance(otio_clip, otio.schema.Transition):
                _transitions.append((otio_track, otio_clip))

            # Create the Clip
            elif isinstance(otio_clip, otio.schema.Clip):
                hiero_clip = create_clip(otio_clip, tags_bin, sequence_bin)

                if not hiero_clip:
                    log.error("Couldn't create hiero clip from otio clip %s", otio_clip.name)
                    continue

                track_item = create_trackitem(
                    playhead,
                    track,
                    otio_clip,
                    hiero_clip
                )

                track.addTrackItem(track_item)

                playhead = track_item.timelineOut() + 1

        # Apply transitions we stored earlier now that all clips are present
        warnings = list()
        for otio_track, otio_item in _transitions:
            # Catch warnings form transitions in case of unsupported transitions
            warning = apply_transition(otio_track, otio_item, track)
            if warning:
                warnings.append(warning)

        if warnings_cb:
            warnings_cb("\n".join(warnings))

def sequence_from_otio_file(otio_path, project=None, sequence=None):
    """Generates a Hiero Sequence from a OTIO file path

    :param otio_path: absolute path of the OTIO file
    :type otio_path: str

    :param project: Hiero project instance, defaults to None
    :type project: core.Hiero.Python.Project, optional

    :param sequence: Hiero sequence instance, defaults to None
    :type sequence: core.Hiero.Python.Sequence, optional
    """

    otio_timeline = otio.adapters.read_from_file(otio_path)
    sequence_from_otio(otio_timeline, project=project, sequence=sequence)
